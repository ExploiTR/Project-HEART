package hacks.exploitr.projectheart.ui;

import android.app.ActivityManager;
import android.content.Context;
import android.content.pm.ActivityInfo;
import android.os.Bundle;
import android.os.Handler;
import android.os.Looper;
import android.view.Display;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.view.WindowManager;

import androidx.annotation.NonNull;
import androidx.fragment.app.Fragment;

import com.jjoe64.graphview.GraphView;
import com.jjoe64.graphview.Viewport;
import com.jjoe64.graphview.series.DataPoint;
import com.jjoe64.graphview.series.LineGraphSeries;

import java.security.SecureRandom;
import java.util.ArrayDeque;
import java.util.Queue;

import hacks.exploitr.projectheart.R;
import hacks.exploitr.projectheart.databinding.FragmentSecondBinding;
import hacks.exploitr.projectheart.system.CpuInfo;
import hacks.exploitr.projectheart.system.NetworkHelper;

public class SecondFragment extends Fragment {

	FragmentChangeListener mListener;
	private FragmentSecondBinding binding;
	private Queue<Integer> resultQueue;
	private Queue<Integer> analysisQueue;
	private Queue<Integer> saveQueue;
	int remove_size;
	long delay = 8; //125hz default
	int refresh_delay;
	private static boolean PAUSE_PLOTTING = false;

	private boolean DRAW_CIRCLES = true;
	private boolean DRAW_VALUES = true;

	private LineGraphSeries<DataPoint> series;
	private int lastX = 0;

	Integer[] padding = new Integer[]{
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
	};

	@Override
	public View onCreateView(@NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
		binding = FragmentSecondBinding.inflate(inflater, container, false);

		Display display = ((WindowManager) getContext().getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
		refresh_delay = (int) (1000 / display.getRefreshRate()); //+1 for safety

		setupChart();

		return binding.getRoot();
	}

	private void setupChart() {
		resultQueue = new ArrayDeque<>();
		analysisQueue = new ArrayDeque<>();
		saveQueue = new ArrayDeque<>();

		GraphView graph = binding.graphEcg;
		series = new LineGraphSeries<>();
		graph.addSeries(series);

		Viewport viewport = graph.getViewport();
		viewport.setYAxisBoundsManual(true);
		viewport.setXAxisBoundsManual(true);
		viewport.setMinY(0);
		viewport.setMaxY(1024);
		viewport.setMinX(0);
		viewport.setMaxX(1250);
		viewport.setScrollable(true);

		new Thread(() -> {
			while (!PAUSE_PLOTTING) {
				if (getActivity() != null) {
					getActivity().runOnUiThread(() -> addEntry(new SecureRandom().nextInt(1000)));
					try {
						Thread.sleep(50);
					} catch (InterruptedException e) {
						//shut
					}
				}
			}
		}).start();

	}

	// add random data to graph
	private void addEntry(int val) {
		// here, we choose to display max 10 points on the viewport and we scroll to end
		series.appendData(new DataPoint(lastX++, val), true, 1250);
	}


	//safer than onViewCreated
	@Override
	public void onStart() {
		super.onStart();

		final SecureRandom random = new SecureRandom();
		NetworkHelper.read(new NetworkHelper.NetworkOperationProgress() {
			@Override
			public void progress(int percent) {

			}

			@Override
			public void result(String what) {
				int val = Integer.parseInt(what);
				if (val == -1)
					val = 512;
				resultQueue.add(val);
				analysisQueue.add(val);
				saveQueue.add(val);
			}
		});

		setupUI();
	}


	private void setupUI() {
		binding.processEnable.setOnClickListener(view -> {
			//enable real-time
			binding.storeEnable.setChecked(false);
			binding.result.setText("View Results");
			binding.result.setOnClickListener(view1 -> showResults());
			startProcessing();
		});

		binding.storeEnable.setOnClickListener(view -> {
			//enable store
			binding.processEnable.setChecked(false);
			binding.result.setText("Save and Process");
			binding.result.setOnClickListener(view1 -> save());
		});

		binding.resumePause.setOnClickListener(view -> PAUSE_PLOTTING = !PAUSE_PLOTTING);

		binding.enableCircles.setOnClickListener(view -> {
			//	lineDataSet.setDrawCircles(DRAW_CIRCLES);
			DRAW_CIRCLES = !DRAW_CIRCLES;
		});

		binding.enableValues.setOnClickListener(view -> {
			//	lineDataSet.setDrawValues(DRAW_VALUES);
			DRAW_VALUES = !DRAW_VALUES;
		});

		ActivityManager.MemoryInfo mi = new ActivityManager.MemoryInfo();
		ActivityManager activityManager = (ActivityManager) getContext().getSystemService(Context.ACTIVITY_SERVICE);
		activityManager.getMemoryInfo(mi);
		final long total_mem = mi.totalMem;

		Handler memHandler = new Handler(Looper.getMainLooper());
		memHandler.post(new Runnable() {
			@Override
			public void run() {
				activityManager.getMemoryInfo(mi);
				if (binding != null)
					binding.memUsage.setText(String.format(getString(R.string.mem_usage_freq_3sec_s), (int) ((total_mem - mi.availMem) / (float) total_mem * 100) + "%"));
				memHandler.postDelayed(this, 3000);
			}
		});


		Handler cpuHandler = new Handler(Looper.getMainLooper());
		cpuHandler.post(new Runnable() {
			@Override
			public void run() {
				if (binding != null)
					binding.cpuUsage.setText(String.format(getString(R.string.cpu_usage_freq_3sec_1_s), CpuInfo.getCpuUsageFromFreq() + "%"));
				cpuHandler.postDelayed(this, 3000);
			}
		});
	}

	private void startProcessing() {
	/*
		AI.getInstance().getType(this.getContext(), nullfirstInput_3, new AI.AnswerListener() {
			@Override
			public void output(int out) {
				System.out.println(AI.DISEASES[out]);
				System.out.println(System.currentTimeMillis());
			}

			@Override
			public void errorDes(String err) {

			}
		});*/
	}

	private void showResults() {
		//todo
	}

	private void save() {
		//todo
	}

	@Override
	public void onResume() {
		super.onResume();
		requireActivity().setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_USER_LANDSCAPE);
		mListener.onChangeTo(getString(R.string.second_fragment_label));
	}

	@Override
	public void onAttach(@NonNull Context context) {
		super.onAttach(context);
		if (context instanceof FragmentChangeListener) {
			mListener = (FragmentChangeListener) context;
		} else {
			throw new RuntimeException(context.toString()
					+ " must implement FragmentChangeListener");
		}
	}

	@Override
	public void onDetach() {
		super.onDetach();
		mListener = null;
	}

	@Override
	public void onDestroyView() {
		super.onDestroyView();
		requireActivity().setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED);
		requireActivity().getWindow().clearFlags(WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS);
		binding = null;
	}

}