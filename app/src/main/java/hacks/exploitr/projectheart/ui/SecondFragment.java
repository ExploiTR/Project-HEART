package hacks.exploitr.projectheart.ui;

import android.app.ActivityManager;
import android.content.Context;
import android.content.Intent;
import android.content.pm.ActivityInfo;
import android.graphics.Color;
import android.os.Bundle;
import android.os.Handler;
import android.os.Looper;
import android.util.Log;
import android.view.Display;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.view.WindowManager;

import androidx.annotation.NonNull;
import androidx.core.content.ContextCompat;
import androidx.fragment.app.Fragment;

import com.github.mikephil.charting.charts.LineChart;
import com.github.mikephil.charting.components.Description;
import com.github.mikephil.charting.components.Legend;
import com.github.mikephil.charting.components.XAxis;
import com.github.mikephil.charting.components.YAxis;
import com.github.mikephil.charting.data.Entry;
import com.github.mikephil.charting.data.LineData;
import com.github.mikephil.charting.data.LineDataSet;
import com.github.mikephil.charting.highlight.Highlight;
import com.github.mikephil.charting.interfaces.datasets.ILineDataSet;
import com.github.mikephil.charting.listener.OnChartValueSelectedListener;
import com.github.mikephil.charting.utils.ColorTemplate;

import java.security.SecureRandom;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.List;
import java.util.Queue;

import hacks.exploitr.projectheart.R;
import hacks.exploitr.projectheart.databinding.FragmentSecondBinding;
import hacks.exploitr.projectheart.system.CpuInfo;
import hacks.exploitr.projectheart.system.NetworkHelper;

public class SecondFragment extends Fragment implements OnChartValueSelectedListener, NetworkHelper.NetworkOperationProgress {

	FragmentChangeListener mListener;
	private FragmentSecondBinding binding;
	private static int resultQueue = 500;
	private Queue<Integer> analysisQueue; //todo highlight
	public static final ArrayList<Integer> saveQueue = new ArrayList<>();
	long delay = 8; //125hz default
	int refresh_delay;
	private static boolean PAUSE_PLOTTING = false;
	LineChart chart;

	int x = 0;

	private static volatile ArrayList<Integer> listValues;

	private boolean DRAW_CIRCLES = true;
	private boolean DRAW_VALUES = true;

	private int lastX = 0;

	Integer[] padding = new Integer[]{
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
	};

	@Override
	public View onCreateView(@NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
		binding = FragmentSecondBinding.inflate(inflater, container, false);

		Display display = ((WindowManager) getContext().getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
		refresh_delay = (int) (1000 / display.getRefreshRate()); //+1 for safety

		setupChart();

		return binding.getRoot();
	}

	private void setupChart() {
		analysisQueue = new ArrayDeque<>();
		listValues = new ArrayList<>();

		chart = binding.graphEcg;

		chart.setOnChartValueSelectedListener(this);

		Description description = new Description();
		description.setText("125Hz Sampling");
		chart.setDescription(description);

		chart.getDescription().setEnabled(true);
		chart.setTouchEnabled(true);
		chart.setDragEnabled(true);
		chart.setScaleEnabled(true);
		chart.setDrawGridBackground(false);
		chart.setPinchZoom(true);
		chart.setBackgroundColor(Color.WHITE);

		LineData data = new LineData();
		data.setValueTextColor(Color.RED);
		chart.setData(data);

		Legend l = chart.getLegend();
		l.setTextColor(Color.BLACK);

		XAxis xl = chart.getXAxis();
		xl.setTextColor(Color.BLACK);
		xl.setDrawGridLines(false);
		xl.setAvoidFirstLastClipping(true);
		xl.setEnabled(true);

		YAxis leftAxis = chart.getAxisLeft();
		leftAxis.setTextColor(Color.BLACK);
		leftAxis.setAxisMaximum(1000f);
		leftAxis.setAxisMinimum(0f);
		leftAxis.setDrawGridLines(true);

		YAxis rightAxis = chart.getAxisRight();
		rightAxis.setEnabled(false);

		setupUI();
		feed();

		final SecureRandom random = new SecureRandom();
		NetworkHelper.read(this);
	}

	private void addEntry(int value) {
		LineData data = chart.getData();
		if (data != null) {
			ILineDataSet set = data.getDataSetByIndex(0);
			if (set == null) {
				set = createSet();
				data.addDataSet(set);
			}

			data.addEntry(new Entry(set.getEntryCount(), value), 0);
			data.notifyDataChanged();

			chart.notifyDataSetChanged();
			chart.setVisibleXRangeMaximum(1250);
			chart.moveViewToX(data.getEntryCount());
		}
	}

	private LineDataSet createSet() {
		LineDataSet set = new LineDataSet(null, "EKG Data");
		set.setAxisDependency(YAxis.AxisDependency.LEFT);
		set.setColor(ColorTemplate.getHoloBlue());
		set.setCircleColor(Color.RED);
		set.setLineWidth(2f);
		set.setCircleRadius(4f);
		set.setFillAlpha(65);
		set.setFillColor(ColorTemplate.colorWithAlpha(Color.RED, 255));
		set.setHighLightColor(Color.rgb(244, 117, 117));
		set.setValueTextColor(Color.RED);
		set.setValueTextSize(9f);
		set.setDrawCircles(true);
		set.setDrawValues(true);
		return set;
	}

	private void feed() {
		Handler handler = new Handler(Looper.getMainLooper());
		handler.post(new Runnable() {
			@Override
			public void run() {
				if (!PAUSE_PLOTTING) {
					addEntry(resultQueue);
					saveQueue.add(resultQueue);
					analysisQueue.add(resultQueue);
				}
				handler.postDelayed(this, 8);
			}
		});
	}


	private void setupUI() {
		binding.processEnable.setOnClickListener(view -> {
			//enable real-time
			binding.storeEnable.setChecked(false);
			binding.result.setText("View Results");
			binding.result.setEnabled(true);
			binding.result.setOnClickListener(view1 -> showResults());
			startProcessing();
		});

		binding.storeEnable.setOnClickListener(view -> {
			//enable store
			binding.processEnable.setChecked(false);
			binding.result.setText("Save and Process");
			binding.result.setBackgroundColor(ContextCompat.getColor(getContext(), R.color.purple_700));
			binding.result.setEnabled(true);
			binding.result.setOnClickListener(view1 -> save());
		});

		binding.resumePause.setOnClickListener(view -> PAUSE_PLOTTING = !PAUSE_PLOTTING);

		binding.enableCircles.setOnClickListener(view -> {
			//	lineDataSet.setDrawCircles(DRAW_CIRCLES);
			DRAW_CIRCLES = !DRAW_CIRCLES;
		});

		binding.enableValues.setOnClickListener(view -> {
			//lineDataSet.setDrawValues(DRAW_VALUES);
			DRAW_VALUES = !DRAW_VALUES;
		});

		ActivityManager.MemoryInfo mi = new ActivityManager.MemoryInfo();
		ActivityManager activityManager = (ActivityManager) getContext().getSystemService(Context.ACTIVITY_SERVICE);
		activityManager.getMemoryInfo(mi);
		final long total_mem = mi.totalMem;

		Handler memHandler = new Handler(Looper.getMainLooper());
		memHandler.post(new Runnable() {
			@Override
			public void run() {
				activityManager.getMemoryInfo(mi);
				if (binding != null)
					binding.memUsage.setText(String.format(getString(R.string.mem_usage_freq_3sec_s), (int) ((total_mem - mi.availMem) / (float) total_mem * 100) + "%"));
				memHandler.postDelayed(this, 3000);
			}
		});


		Handler cpuHandler = new Handler(Looper.getMainLooper());
		cpuHandler.post(new Runnable() {
			@Override
			public void run() {
				if (binding != null)
					binding.cpuUsage.setText(String.format(getString(R.string.cpu_usage_freq_3sec_1_s), CpuInfo.getCpuUsageFromFreq() + "%"));
				cpuHandler.postDelayed(this, 3000);
			}
		});
	}

	/*todo start processing data here*/
	private void startProcessing() {

	}

	/*todo show  processes data here*/
	private void showResults() {
	}

	private void save() {
		PAUSE_PLOTTING = true;
		Intent intent = new Intent(getActivity(), Processing.class);
		intent.putIntegerArrayListExtra("datar",saveQueue);
		startActivity(new Intent(getActivity(), Processing.class));
	}

	@Override
	public void onResume() {
		super.onResume();
		requireActivity().setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_USER_LANDSCAPE);
		mListener.onChangeTo(getString(R.string.second_fragment_label));
	}

	@Override
	public void onAttach(@NonNull Context context) {
		super.onAttach(context);
		if (context instanceof FragmentChangeListener) {
			mListener = (FragmentChangeListener) context;
		} else {
			throw new RuntimeException(context.toString()
					+ " must implement FragmentChangeListener");
		}
	}

	@Override
	public void onDetach() {
		super.onDetach();
		mListener = null;
	}

	@Override
	public void onDestroyView() {
		super.onDestroyView();
		requireActivity().setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED);
		requireActivity().getWindow().clearFlags(WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS);
		binding = null;
	}

	@Override
	public void onValueSelected(Entry e, Highlight h) {
		Log.i("Entry selected", e.toString());
	}

	@Override
	public void onNothingSelected() {
		Log.i("Nothing selected", "Nothing selected.");
	}

	@Override
	public void progress(int percent) {

	}

	@Override
	public void result(String what) {
		int val = Integer.parseInt(what);
		if (val == -1)
			val = 500;
		resultQueue = val;
	}

}